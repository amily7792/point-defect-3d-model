<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>α-Fe晶格空位与间隙扩散模拟（优化界面布局与八面体间隙运动）</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(to bottom, #1a1a2e, #16213e);
            color: #fff;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 60px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            max-width: 380px;
            border-left: 4px solid #3498db;
            z-index: 10;
            transition: opacity 0.3s ease;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 10;
        }
        button {
            padding: 8px 16px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 12px;
        }
        button:hover {
            background: #2980b9;
        }
        #temperature {
            background: #e74c3c;
            padding: 8px 16px;
            border-radius: 4px;
            min-width: 100px;
            text-align: center;
        }
        h1 {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            margin: 0;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            font-size: 1.5em;
            border-bottom: 3px solid #3498db;
            z-index: 10;
            transition: opacity 0.3s ease;
        }
        .legend {
            display: flex;
            align-items: center;
            margin: 5px 0;
            justify-content: space-between;
        }
        .legend-content {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }
        .color-box {
            width: 15px;
            height: 15px;
            margin-right: 10px;
            border-radius: 50%;
        }
        .blue {
            background: #3498db;
        }
        .white {
            background: #fff;
            border: 1px solid #ccc;
        }
        .cyan {
            background: #1abc9c;
        }
        .green {
            background: #2ecc71;
        }
        .purple {
            background: #9b59b6;
        }
        .black {
            background: #2c3e50;
        }
        .orange {
            background: #e67e22;
        }
        .yellow {
            background: #f1c40f;
        }
        #mode-panel {
            position: absolute;
            top: 60px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 10;
            transition: opacity 0.3s ease;
            max-width: 250px;
        }
        .mode-btn {
            display: block;
            width: 100%;
            margin: 5px 0;
        }
        .active {
            background: #e74c3c;
        }
        #toggle-ui {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
        #status {
            position: absolute;
            bottom: 80px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 10;
            transition: opacity 0.3s ease;
            max-width: 250px;
        }
        .toggle-btn {
            padding: 4px 8px;
            font-size: 10px;
            margin-left: 5px;
        }
        .toggle-btn.on {
            background: #2ecc71;
        }
        .toggle-btn.off {
            background: #e74c3c;
        }
        .section-title {
            margin-top: 15px;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 5px;
        }
        .sub-mode {
            margin-left: 15px;
            border-left: 2px solid rgba(255,255,255,0.2);
            padding-left: 10px;
        }
        .sub-btn {
            display: block;
            width: 100%;
            margin: 5px 0;
            background: #2980b9;
            font-size: 11px;
        }
        .sub-btn.active {
            background: #e74c3c;
        }
    </style>
</head>
<body>
    <button id="toggle-ui">隐藏说明</button>
    <h1>α-Fe晶格空位与间隙扩散模拟（优化界面布局与八面体间隙运动）</h1>
    <div id="container">
        <div id="info">
            <h3>模拟说明</h3>
            <div class="section-title">原子类型控制</div>
            <div class="legend">
                <div class="legend-content">
                    <div class="color-box blue"></div>
                    <span>正常铁原子</span>
                </div>
                <button id="toggle-atoms" class="toggle-btn on">显示</button>
            </div>
            <div class="legend">
                <div class="legend-content">
                    <div class="color-box white"></div>
                    <span>空位</span>
                </div>
                <button id="toggle-vacancies" class="toggle-btn on">显示</button>
            </div>
            <div class="legend">
                <div class="legend-content">
                    <div class="color-box cyan"></div>
                    <span>跳跃原子轨迹</span>
                </div>
                <button id="toggle-paths" class="toggle-btn on">显示</button>
            </div>
            <div class="legend">
                <div class="legend-content">
                    <div class="color-box green"></div>
                    <span>四面体间隙</span>
                </div>
                <button id="toggle-tetrahedral" class="toggle-btn on">显示</button>
            </div>
            <div class="legend">
                <div class="legend-content">
                    <div class="color-box purple"></div>
                    <span>八面体间隙</span>
                </div>
                <button id="toggle-octahedral" class="toggle-btn on">显示</button>
            </div>
            <div class="legend">
                <div class="legend-content">
                    <div class="color-box black"></div>
                    <span>C原子</span>
                </div>
                <button id="toggle-c-atoms" class="toggle-btn on">显示</button>
            </div>
            <div class="legend">
                <div class="legend-content">
                    <div class="color-box orange"></div>
                    <span>N原子</span>
                </div>
                <button id="toggle-n-atoms" class="toggle-btn on">显示</button>
            </div>
            <div class="legend">
                <div class="legend-content">
                    <div class="color-box yellow"></div>
                    <span>畸变区域</span>
                </div>
                <button id="toggle-distortion" class="toggle-btn on">显示</button>
            </div>
            
            <div class="section-title">模拟说明</div>
            <p>在α-Fe晶格中，热激发会导致铁原子脱离格点形成空位，邻近原子会跳入空位，使空位在晶格中"迁移"。</p>
            <p>BCC结构中存在四面体和八面体两类间隙，其中四面体间隙相对较大，能够容纳C、N、H等小原子进入晶格间隙形成间隙固溶体。</p>
            <p>这种间隙的存在是钢铁材料中点缺陷普遍出现的根本原因，也为C原子在α-Fe中的快速扩散提供了条件。</p>
        </div>
        
        <!-- 右侧面板：模式选择 -->
        <div id="mode-panel">
            <h3>扩散模式</h3>
            <button id="vacancy-mode" class="mode-btn active">空位扩散</button>
            
            <div class="sub-mode">
                <button id="interstitial-mode" class="mode-btn">间隙扩散</button>
                <button id="toggle-c-diffusion" class="sub-btn">C原子扩散: 开</button>
                <button id="toggle-n-diffusion" class="sub-btn">N原子扩散: 开</button>
            </div>
            
            <button id="combined-mode" class="mode-btn">综合模式</button>
        </div>
        
        <!-- 当前状态 - 移到右下方 -->
        <div id="status">
            <h3>当前状态</h3>
            <p>模式: <span id="current-mode">空位扩散</span></p>
            <p>温度: <span id="current-temp">300</span> K</p>
            <p>状态: <span id="current-state">运行中</span></p>
        </div>
        
        <div id="controls">
            <button id="playPause">暂停</button>
            <button id="reset">重置</button>
            <button id="cool">降温</button>
            <div id="temperature">温度: 300 K</div>
            <button id="heat">升温</button>
        </div>
    </div>

    <script>
        // 初始化Three.js场景
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0f1a2e);
        document.getElementById('container').appendChild(renderer.domElement);

        // 添加轨道控制器（手动旋转）
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // 添加光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);

        // 相机位置
        camera.position.set(8, 8, 8);
        camera.lookAt(0, 0, 0);

        // α-Fe晶格参数 (BCC结构)
        const latticeConstant = 2.87; // α-Fe的晶格常数(Å)
        const atomRadius = 0.3;
        const vacancyRadius = 0.4;
        const interstitialRadius = 0.15;
        const cAtomRadius = 0.2;
        const nAtomRadius = 0.18;

        // 创建BCC晶格原子
        const atoms = [];
        const vacancies = [];
        const tetrahedralSites = []; // 四面体间隙
        const octahedralSites = []; // 八面体间隙
        const cAtoms = []; // C原子
        const nAtoms = []; // N原子
        const atomGroup = new THREE.Group();
        scene.add(atomGroup);

        // 创建原子材料 - 蓝色
        const atomMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x3498db, // 铁原子颜色 - 蓝色
            shininess: 30
        });

        // 创建空位材料 (透明圆圈)
        const vacancyMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            transparent: true, 
            opacity: 0.8,
            side: THREE.DoubleSide
        });

        // 创建轨迹材料 - 青色
        const pathMaterial = new THREE.LineBasicMaterial({ color: 0x1abc9c });

        // 创建四面体间隙材料 - 绿色
        const tetrahedralMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x2ecc71,
            transparent: true,
            opacity: 0.7
        });

        // 创建八面体间隙材料 - 紫色
        const octahedralMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x9b59b6,
            transparent: true,
            opacity: 0.7
        });

        // 创建C原子材料 - 黑色
        const cAtomMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x2c3e50,
            shininess: 50
        });

        // 创建N原子材料 - 橙色
        const nAtomMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xe67e22,
            shininess: 50
        });

        // 创建畸变区域材料
        const distortionMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xf1c40f,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });

        // 生成BCC晶格原子
        const unitCells = 2; // 每个方向上的晶胞数
        for (let i = -unitCells; i <= unitCells; i++) {
            for (let j = -unitCells; j <= unitCells; j++) {
                for (let k = -unitCells; k <= unitCells; k++) {
                    // 顶点原子
                    createAtom(i, j, k);
                    
                    // 体心原子
                    if (i < unitCells && j < unitCells && k < unitCells) {
                        createAtom(i + 0.5, j + 0.5, k + 0.5);
                    }
                }
            }
        }

        // 生成四面体间隙位置
        for (let i = -unitCells; i <= unitCells; i++) {
            for (let j = -unitCells; j <= unitCells; j++) {
                for (let k = -unitCells; k <= unitCells; k++) {
                    // BCC结构中的四面体间隙位置
                    // 每个晶胞有12个四面体间隙
                    const positions = [
                        [0.25, 0.5, 0], [0.75, 0.5, 0],
                        [0.5, 0.25, 0], [0.5, 0.75, 0],
                        [0.5, 0, 0.25], [0.5, 0, 0.75],
                        [0, 0.25, 0.5], [0, 0.75, 0.5],
                        [0.25, 0, 0.5], [0.75, 0, 0.5],
                        [0, 0.5, 0.25], [0, 0.5, 0.75]
                    ];
                    
                    for (const pos of positions) {
                        createTetrahedralSite(
                            i + pos[0], 
                            j + pos[1], 
                            k + pos[2]
                        );
                    }
                }
            }
        }

        // 生成八面体间隙位置
        for (let i = -unitCells; i <= unitCells; i++) {
            for (let j = -unitCells; j <= unitCells; j++) {
                for (let k = -unitCells; k <= unitCells; k++) {
                    // BCC结构中的八面体间隙位置
                    // 每个晶胞有6个八面体间隙
                    const positions = [
                        [0.5, 0.5, 0.5],  // 体心位置
                        [0.5, 0, 0],      // 面心位置
                        [0, 0.5, 0],      // 面心位置
                        [0, 0, 0.5],      // 面心位置
                        [0.5, 0.5, 1],    // 相邻晶胞
                        [0.5, 1, 0.5],    // 相邻晶胞
                        [1, 0.5, 0.5]     // 相邻晶胞
                    ];
                    
                    for (const pos of positions) {
                        createOctahedralSite(
                            i + pos[0], 
                            j + pos[1], 
                            k + pos[2]
                        );
                    }
                }
            }
        }

        // 创建C原子（随机放置在四面体间隙中）
        for (let i = 0; i < 3; i++) {
            const randomIndex = Math.floor(Math.random() * tetrahedralSites.length);
            const site = tetrahedralSites[randomIndex];
            createCAtom(site.position.x, site.position.y, site.position.z);
        }

        // 创建N原子（随机放置在八面体间隙中）
        for (let i = 0; i < 3; i++) {
            const randomIndex = Math.floor(Math.random() * octahedralSites.length);
            const site = octahedralSites[randomIndex];
            createNAtom(site.position.x, site.position.y, site.position.z);
        }

        function createAtom(x, y, z) {
            const geometry = new THREE.SphereGeometry(atomRadius, 16, 16);
            const atom = new THREE.Mesh(geometry, atomMaterial);
            atom.position.set(x * latticeConstant, y * latticeConstant, z * latticeConstant);
            atom.userData.originalPosition = atom.position.clone();
            atom.userData.isVacancy = false;
            atom.userData.displaced = false;
            atoms.push(atom);
            atomGroup.add(atom);
        }

        function createTetrahedralSite(x, y, z) {
            const geometry = new THREE.SphereGeometry(interstitialRadius, 12, 12);
            const site = new THREE.Mesh(geometry, tetrahedralMaterial);
            site.position.set(x * latticeConstant, y * latticeConstant, z * latticeConstant);
            tetrahedralSites.push(site);
            atomGroup.add(site);
            return site;
        }

        function createOctahedralSite(x, y, z) {
            const geometry = new THREE.SphereGeometry(interstitialRadius, 12, 12);
            const site = new THREE.Mesh(geometry, octahedralMaterial);
            site.position.set(x * latticeConstant, y * latticeConstant, z * latticeConstant);
            octahedralSites.push(site);
            atomGroup.add(site);
            return site;
        }

        function createCAtom(x, y, z) {
            const geometry = new THREE.SphereGeometry(cAtomRadius, 16, 16);
            const cAtom = new THREE.Mesh(geometry, cAtomMaterial);
            cAtom.position.set(x, y, z);
            cAtom.userData.originalPosition = cAtom.position.clone();
            cAtom.userData.isMoving = false;
            cAtoms.push(cAtom);
            atomGroup.add(cAtom);
            return cAtom;
        }

        function createNAtom(x, y, z) {
            const geometry = new THREE.SphereGeometry(nAtomRadius, 16, 16);
            const nAtom = new THREE.Mesh(geometry, nAtomMaterial);
            nAtom.position.set(x, y, z);
            nAtom.userData.originalPosition = nAtom.position.clone();
            nAtom.userData.isMoving = false;
            nAtoms.push(nAtom);
            atomGroup.add(nAtom);
            return nAtom;
        }

        // 创建初始空位 (中心位置)
        const initialVacancyPos = new THREE.Vector3(0, 0, 0);
        createVacancy(initialVacancyPos);
        
        // 标记中心原子为空位
        const centerAtom = findAtomAtPosition(initialVacancyPos);
        if (centerAtom) {
            centerAtom.userData.isVacancy = true;
        }

        function createVacancy(position) {
            const geometry = new THREE.SphereGeometry(vacancyRadius, 16, 16);
            const vacancy = new THREE.Mesh(geometry, vacancyMaterial);
            vacancy.position.copy(position);
            vacancies.push(vacancy);
            atomGroup.add(vacancy);
            return vacancy;
        }

        function findAtomAtPosition(position) {
            for (const atom of atoms) {
                if (atom.position.distanceTo(position) < 0.1) {
                    return atom;
                }
            }
            return null;
        }

        // 寻找邻近原子
        function findNeighborAtoms(vacancyPosition) {
            const neighbors = [];
            const directions = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, -1, 0),
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, -1),
                // BCC结构中的体心到顶点方向
                new THREE.Vector3(0.5, 0.5, 0.5),
                new THREE.Vector3(0.5, 0.5, -0.5),
                new THREE.Vector3(0.5, -0.5, 0.5),
                new THREE.Vector3(0.5, -0.5, -0.5),
                new THREE.Vector3(-0.5, 0.5, 0.5),
                new THREE.Vector3(-0.5, 0.5, -0.5),
                new THREE.Vector3(-0.5, -0.5, 0.5),
                new THREE.Vector3(-0.5, -0.5, -0.5)
            ];

            for (const dir of directions) {
                const neighborPos = vacancyPosition.clone().add(dir.multiplyScalar(latticeConstant));
                const atom = findAtomAtPosition(neighborPos);
                if (atom && !atom.userData.isVacancy) {
                    neighbors.push(atom);
                }
            }

            return neighbors;
        }

        // 寻找邻近的四面体间隙（用于C原子扩散）
        function findNeighborTetrahedrals(cAtomPosition) {
            const neighbors = [];
            // C原子在四面体间隙之间的跳跃方向
            const directions = [
                new THREE.Vector3(0.25, 0.25, 0),
                new THREE.Vector3(-0.25, -0.25, 0),
                new THREE.Vector3(0.25, -0.25, 0),
                new THREE.Vector3(-0.25, 0.25, 0),
                new THREE.Vector3(0.25, 0, 0.25),
                new THREE.Vector3(-0.25, 0, -0.25),
                new THREE.Vector3(0.25, 0, -0.25),
                new THREE.Vector3(-0.25, 0, 0.25),
                new THREE.Vector3(0, 0.25, 0.25),
                new THREE.Vector3(0, -0.25, -0.25),
                new THREE.Vector3(0, 0.25, -0.25),
                new THREE.Vector3(0, -0.25, 0.25)
            ];

            for (const dir of directions) {
                const neighborPos = cAtomPosition.clone().add(dir.multiplyScalar(latticeConstant));
                // 查找最近的四面体间隙
                let closestSite = null;
                let minDistance = Infinity;
                
                for (const site of tetrahedralSites) {
                    const distance = site.position.distanceTo(neighborPos);
                    if (distance < minDistance && distance < 0.3) {
                        minDistance = distance;
                        closestSite = site;
                    }
                }
                
                if (closestSite) {
                    // 检查这个位置是否已经有C原子
                    let occupied = false;
                    for (const cAtom of cAtoms) {
                        if (cAtom.position.distanceTo(closestSite.position) < 0.2 && !cAtom.userData.isMoving) {
                            occupied = true;
                            break;
                        }
                    }
                    
                    if (!occupied) {
                        neighbors.push(closestSite);
                    }
                }
            }

            return neighbors;
        }

        // 寻找邻近的八面体间隙（用于N原子扩散）
        function findNeighborOctahedrals(nAtomPosition) {
            const neighbors = [];
            // N原子在八面体间隙之间的跳跃方向
            const directions = [
                new THREE.Vector3(0.5, 0, 0),
                new THREE.Vector3(-0.5, 0, 0),
                new THREE.Vector3(0, 0.5, 0),
                new THREE.Vector3(0, -0.5, 0),
                new THREE.Vector3(0, 0, 0.5),
                new THREE.Vector3(0, 0, -0.5)
            ];

            for (const dir of directions) {
                const neighborPos = nAtomPosition.clone().add(dir.multiplyScalar(latticeConstant));
                // 查找最近的八面体间隙
                let closestSite = null;
                let minDistance = Infinity;
                
                for (const site of octahedralSites) {
                    const distance = site.position.distanceTo(neighborPos);
                    if (distance < minDistance && distance < 0.3) {
                        minDistance = distance;
                        closestSite = site;
                    }
                }
                
                if (closestSite) {
                    // 检查这个位置是否已经有N原子
                    let occupied = false;
                    for (const nAtom of nAtoms) {
                        if (nAtom.position.distanceTo(closestSite.position) < 0.2 && !nAtom.userData.isMoving) {
                            occupied = true;
                            break;
                        }
                    }
                    
                    if (!occupied) {
                        neighbors.push(closestSite);
                    }
                }
            }

            return neighbors;
        }

        // 动画状态
        let animationState = {
            isPlaying: true,
            temperature: 300, // 初始温度 300K
            currentVacancy: vacancies[0],
            jumpingAtom: null,
            jumpProgress: 0,
            jumpPath: null,
            neighbors: findNeighborAtoms(initialVacancyPos),
            autoRotate: false,
            mode: 'vacancy', // 'vacancy', 'interstitial', 'combined'
            movingCAtoms: [], // 正在移动的C原子及其目标位置
            movingNAtoms: [], // 正在移动的N原子及其目标位置
            uiVisible: true,
            showAtoms: true,
            showVacancies: true,
            showPaths: true,
            showTetrahedral: true,
            showOctahedral: true,
            showCAtoms: true,
            showNAtoms: true,
            showDistortion: true,
            enableCDiffusion: true,
            enableNDiffusion: true,
            distortionSpheres: [] // 存储畸变区域球体
        };

        // 计算跳跃概率（与温度相关）
        function getJumpProbability() {
            // 使用阿伦尼乌斯方程简化版：跳跃概率随温度指数增加
            return 0.005 * Math.exp((animationState.temperature - 300) / 100);
        }

        // 计算C原子跳跃概率（与温度相关）
        function getCAtomJumpProbability() {
            // C原子在间隙中的跳跃概率通常比空位扩散高
            return 0.01 * Math.exp((animationState.temperature - 300) / 80);
        }

        // 计算N原子跳跃概率（与温度相关）
        function getNAtomJumpProbability() {
            // N原子在间隙中的跳跃概率通常比C原子低
            return 0.008 * Math.exp((animationState.temperature - 300) / 90);
        }

        // 创建更准确的跳跃路径
        function createJumpPath(from, to) {
            const points = [];
            
            // 在BCC结构中，原子跳跃路径是直线，但为了可视化能量势垒，我们添加轻微弯曲
            const numPoints = 20;
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                
                // 线性插值
                const point = from.clone().lerp(to, t);
                
                // 添加轻微弯曲模拟能量势垒
                // 弯曲高度与温度相关 - 温度越高，势垒越小
                const barrierHeight = 0.3 * (1 - (animationState.temperature - 100) / 700);
                point.y += barrierHeight * Math.sin(Math.PI * t);
                
                points.push(point);
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            return new THREE.Line(geometry, pathMaterial);
        }

        // 创建畸变区域
        function createDistortionSphere(position, radius) {
            const geometry = new THREE.SphereGeometry(radius, 16, 16);
            const sphere = new THREE.Mesh(geometry, distortionMaterial);
            sphere.position.copy(position);
            animationState.distortionSpheres.push(sphere);
            atomGroup.add(sphere);
            return sphere;
        }

        // 更新畸变效果 - 根据模式和原子显示状态显示对应的畸变区域
        function updateDistortion() {
            // 清除之前的畸变区域
            animationState.distortionSpheres.forEach(sphere => {
                atomGroup.remove(sphere);
            });
            animationState.distortionSpheres = [];
            
            if (!animationState.showDistortion) return;
            
            // 重置所有原子的位移状态
            atoms.forEach(atom => {
                atom.userData.displaced = false;
                if (!atom.userData.isVacancy) {
                    atom.position.copy(atom.userData.originalPosition);
                }
            });
            
            // 空位扩散模式：只显示空位周围的畸变区域（当空位显示时）
            if ((animationState.mode === 'vacancy' || animationState.mode === 'combined') && animationState.showVacancies) {
                // 为每个空位创建畸变区域
                vacancies.forEach(vacancy => {
                    // 创建畸变球体
                    const distortionRadius = latticeConstant * 1.2;
                    createDistortionSphere(vacancy.position, distortionRadius);
                    
                    // 计算空位周围的原子位移
                    atoms.forEach(atom => {
                        if (atom.userData.isVacancy) return;
                        
                        const distance = atom.position.distanceTo(vacancy.position);
                        if (distance < distortionRadius) {
                            // 计算位移方向和大小
                            const direction = new THREE.Vector3().subVectors(atom.position, vacancy.position).normalize();
                            // 距离越近，位移越大
                            const displacementAmount = (1 - distance / distortionRadius) * 0.2;
                            
                            // 应用位移
                            atom.position.add(direction.multiplyScalar(displacementAmount));
                            atom.userData.displaced = true;
                        }
                    });
                });
            }
            
            // 间隙扩散模式：只显示C和N原子周围的畸变区域（当对应原子显示时）
            if (animationState.mode === 'interstitial' || animationState.mode === 'combined') {
                // 为每个C原子创建畸变区域（当C原子显示时）
                if (animationState.showCAtoms) {
                    cAtoms.forEach(cAtom => {
                        // 创建畸变球体
                        const distortionRadius = latticeConstant * 0.8;
                        createDistortionSphere(cAtom.position, distortionRadius);
                        
                        // 计算C原子周围的原子位移
                        atoms.forEach(atom => {
                            if (atom.userData.isVacancy) return;
                            
                            const distance = atom.position.distanceTo(cAtom.position);
                            if (distance < distortionRadius) {
                                // 计算位移方向和大小
                                const direction = new THREE.Vector3().subVectors(atom.position, cAtom.position).normalize();
                                // 距离越近，位移越大
                                const displacementAmount = (1 - distance / distortionRadius) * 0.15;
                                
                                // 应用位移
                                atom.position.add(direction.multiplyScalar(displacementAmount));
                                atom.userData.displaced = true;
                            }
                        });
                    });
                }
                
                // 为每个N原子创建畸变区域（当N原子显示时）
                if (animationState.showNAtoms) {
                    nAtoms.forEach(nAtom => {
                        // 创建畸变球体
                        const distortionRadius = latticeConstant * 0.7;
                        createDistortionSphere(nAtom.position, distortionRadius);
                        
                        // 计算N原子周围的原子位移
                        atoms.forEach(atom => {
                            if (atom.userData.isVacancy) return;
                            
                            const distance = atom.position.distanceTo(nAtom.position);
                            if (distance < distortionRadius) {
                                // 计算位移方向和大小
                                const direction = new THREE.Vector3().subVectors(atom.position, nAtom.position).normalize();
                                // 距离越近，位移越大
                                const displacementAmount = (1 - distance / distortionRadius) * 0.12;
                                
                                // 应用位移
                                atom.position.add(direction.multiplyScalar(displacementAmount));
                                atom.userData.displaced = true;
                            }
                        });
                    });
                }
            }
        }

        // 更新所有元素的可见性
        function updateVisibility() {
            // 更新铁原子可见性
            atoms.forEach(atom => {
                atom.visible = animationState.showAtoms && !atom.userData.isVacancy;
            });
            
            // 更新空位可见性
            vacancies.forEach(vacancy => {
                vacancy.visible = animationState.showVacancies;
            });
            
            // 更新四面体间隙可见性
            tetrahedralSites.forEach(site => {
                site.visible = (animationState.mode === 'interstitial' || animationState.mode === 'combined') && 
                              animationState.showTetrahedral;
            });
            
            // 更新八面体间隙可见性
            octahedralSites.forEach(site => {
                site.visible = (animationState.mode === 'interstitial' || animationState.mode === 'combined') && 
                              animationState.showOctahedral;
            });
            
            // 更新C原子可见性
            cAtoms.forEach(atom => {
                atom.visible = (animationState.mode === 'interstitial' || animationState.mode === 'combined') && 
                              animationState.showCAtoms;
            });
            
            // 更新N原子可见性
            nAtoms.forEach(atom => {
                atom.visible = (animationState.mode === 'interstitial' || animationState.mode === 'combined') && 
                              animationState.showNAtoms;
            });
            
            // 更新畸变区域可见性
            animationState.distortionSpheres.forEach(sphere => {
                sphere.visible = animationState.showDistortion;
            });
            
            // 更新跳跃路径可见性
            if (animationState.jumpPath) {
                animationState.jumpPath.visible = animationState.showPaths;
            }
            
            animationState.movingCAtoms.forEach(movingAtom => {
                movingAtom.path.visible = animationState.showPaths;
            });
            
            animationState.movingNAtoms.forEach(movingAtom => {
                movingAtom.path.visible = animationState.showPaths;
            });
            
            // 更新按钮文本
            document.getElementById('toggle-atoms').textContent = animationState.showAtoms ? '隐藏' : '显示';
            document.getElementById('toggle-atoms').className = `toggle-btn ${animationState.showAtoms ? 'on' : 'off'}`;
            
            document.getElementById('toggle-vacancies').textContent = animationState.showVacancies ? '隐藏' : '显示';
            document.getElementById('toggle-vacancies').className = `toggle-btn ${animationState.showVacancies ? 'on' : 'off'}`;
            
            document.getElementById('toggle-paths').textContent = animationState.showPaths ? '隐藏' : '显示';
            document.getElementById('toggle-paths').className = `toggle-btn ${animationState.showPaths ? 'on' : 'off'}`;
            
            document.getElementById('toggle-tetrahedral').textContent = animationState.showTetrahedral ? '隐藏' : '显示';
            document.getElementById('toggle-tetrahedral').className = `toggle-btn ${animationState.showTetrahedral ? 'on' : 'off'}`;
            
            document.getElementById('toggle-octahedral').textContent = animationState.showOctahedral ? '隐藏' : '显示';
            document.getElementById('toggle-octahedral').className = `toggle-btn ${animationState.showOctahedral ? 'on' : 'off'}`;
            
            document.getElementById('toggle-c-atoms').textContent = animationState.showCAtoms ? '隐藏' : '显示';
            document.getElementById('toggle-c-atoms').className = `toggle-btn ${animationState.showCAtoms ? 'on' : 'off'}`;
            
            document.getElementById('toggle-n-atoms').textContent = animationState.showNAtoms ? '隐藏' : '显示';
            document.getElementById('toggle-n-atoms').className = `toggle-btn ${animationState.showNAtoms ? 'on' : 'off'}`;
            
            document.getElementById('toggle-distortion').textContent = animationState.showDistortion ? '隐藏' : '显示';
            document.getElementById('toggle-distortion').className = `toggle-btn ${animationState.showDistortion ? 'on' : 'off'}`;
            
            document.getElementById('toggle-c-diffusion').textContent = `C原子扩散: ${animationState.enableCDiffusion ? '开' : '关'}`;
            document.getElementById('toggle-n-diffusion').textContent = `N原子扩散: ${animationState.enableNDiffusion ? '开' : '关'}`;
        }

        // 检查是否可以执行C原子扩散
        function canPerformCDiffusion() {
            return animationState.showTetrahedral && animationState.showCAtoms && animationState.enableCDiffusion;
        }

        // 检查是否可以执行N原子扩散
        function canPerformNDiffusion() {
            return animationState.showOctahedral && animationState.showNAtoms && animationState.enableNDiffusion;
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 更新轨道控制器
            controls.update();
            
            if (animationState.isPlaying) {
                // 自动旋转（可选）
                if (animationState.autoRotate) {
                    atomGroup.rotation.y += 0.002 * (animationState.temperature / 300);
                }
                
                // 处理空位扩散
                if (animationState.mode === 'vacancy' || animationState.mode === 'combined') {
                    if (animationState.jumpingAtom) {
                        // 原子正在跳跃
                        animationState.jumpProgress += 0.02 * (animationState.temperature / 300);
                        
                        if (animationState.jumpProgress >= 1) {
                            // 跳跃完成
                            // 原子移动到空位位置
                            animationState.jumpingAtom.position.copy(animationState.currentVacancy.position);
                            
                            // 更新原子状态
                            animationState.jumpingAtom.userData.isVacancy = false;
                            
                            // 空位移动到原子原来的位置
                            animationState.currentVacancy.position.copy(animationState.jumpingAtom.userData.originalPosition);
                            
                            // 标记新位置为空位
                            const newVacancyAtom = findAtomAtPosition(animationState.currentVacancy.position);
                            if (newVacancyAtom) {
                                newVacancyAtom.userData.isVacancy = true;
                            }
                            
                            // 移除路径
                            scene.remove(animationState.jumpPath);
                            animationState.jumpPath = null;
                            animationState.jumpingAtom = null;
                            animationState.jumpProgress = 0;
                            
                            // 更新邻近原子列表
                            animationState.neighbors = findNeighborAtoms(animationState.currentVacancy.position);
                            
                            // 更新畸变效果
                            updateDistortion();
                        } else {
                            // 更新跳跃原子位置 - 使用更准确的路径
                            const from = animationState.jumpingAtom.userData.originalPosition;
                            const to = animationState.currentVacancy.position;
                            const t = animationState.jumpProgress;
                            
                            // 线性插值
                            const position = from.clone().lerp(to, t);
                            
                            // 添加轻微弯曲模拟能量势垒
                            const barrierHeight = 0.3 * (1 - (animationState.temperature - 100) / 700);
                            position.y += barrierHeight * Math.sin(Math.PI * t);
                            
                            animationState.jumpingAtom.position.copy(position);
                        }
                    } else if (animationState.neighbors.length > 0) {
                        // 根据温度决定是否跳跃
                        if (Math.random() < getJumpProbability()) {
                            // 随机选择一个邻近原子进行跳跃
                            const randomIndex = Math.floor(Math.random() * animationState.neighbors.length);
                            animationState.jumpingAtom = animationState.neighbors[randomIndex];
                            animationState.jumpingAtom.userData.originalPosition = animationState.jumpingAtom.position.clone();
                            
                            // 创建跳跃路径
                            animationState.jumpPath = createJumpPath(
                                animationState.jumpingAtom.position, 
                                animationState.currentVacancy.position
                            );
                            scene.add(animationState.jumpPath);
                        }
                    }
                }
                
                // 处理C原子在四面体间隙中的扩散
                if (animationState.mode === 'interstitial' || animationState.mode === 'combined') {
                    // 只有在四面体间隙和C原子都显示且C原子扩散开启时才进行C原子扩散
                    if (canPerformCDiffusion()) {
                        // 更新正在移动的C原子
                        for (let i = animationState.movingCAtoms.length - 1; i >= 0; i--) {
                            const movingAtom = animationState.movingCAtoms[i];
                            movingAtom.progress += 0.03 * (animationState.temperature / 300);
                            
                            if (movingAtom.progress >= 1) {
                                // 跳跃完成
                                movingAtom.cAtom.position.copy(movingAtom.target);
                                movingAtom.cAtom.userData.isMoving = false;
                                animationState.movingCAtoms.splice(i, 1);
                                
                                // 移除路径
                                scene.remove(movingAtom.path);
                                
                                // 更新畸变效果
                                updateDistortion();
                            } else {
                                // 更新C原子位置
                                const from = movingAtom.cAtom.userData.originalPosition;
                                const to = movingAtom.target;
                                const t = movingAtom.progress;
                                
                                // 线性插值
                                const position = from.clone().lerp(to, t);
                                movingAtom.cAtom.position.copy(position);
                                
                                // 更新畸变效果
                                updateDistortion();
                            }
                        }
                        
                        // 随机选择一个C原子尝试跳跃
                        if (Math.random() < getCAtomJumpProbability() && animationState.movingCAtoms.length < 2) {
                            const availableCAtoms = cAtoms.filter(cAtom => !cAtom.userData.isMoving);
                            if (availableCAtoms.length > 0) {
                                const randomIndex = Math.floor(Math.random() * availableCAtoms.length);
                                const cAtom = availableCAtoms[randomIndex];
                                const neighbors = findNeighborTetrahedrals(cAtom.position);
                                
                                if (neighbors.length > 0) {
                                    const targetIndex = Math.floor(Math.random() * neighbors.length);
                                    const target = neighbors[targetIndex].position;
                                    
                                    cAtom.userData.isMoving = true;
                                    cAtom.userData.originalPosition = cAtom.position.clone();
                                    
                                    // 创建路径
                                    const path = createJumpPath(cAtom.position, target);
                                    scene.add(path);
                                    
                                    animationState.movingCAtoms.push({
                                        cAtom: cAtom,
                                        target: target,
                                        progress: 0,
                                        path: path
                                    });
                                }
                            }
                        }
                    } else {
                        // 如果四面体间隙或C原子被隐藏，停止所有C原子的运动
                        for (let i = animationState.movingCAtoms.length - 1; i >= 0; i--) {
                            const movingAtom = animationState.movingCAtoms[i];
                            scene.remove(movingAtom.path);
                            movingAtom.cAtom.position.copy(movingAtom.cAtom.userData.originalPosition);
                            movingAtom.cAtom.userData.isMoving = false;
                        }
                        animationState.movingCAtoms = [];
                    }
                    
                    // 处理N原子在八面体间隙中的扩散
                    if (canPerformNDiffusion()) {
                        // 更新正在移动的N原子
                        for (let i = animationState.movingNAtoms.length - 1; i >= 0; i--) {
                            const movingAtom = animationState.movingNAtoms[i];
                            movingAtom.progress += 0.025 * (animationState.temperature / 300);
                            
                            if (movingAtom.progress >= 1) {
                                // 跳跃完成
                                movingAtom.nAtom.position.copy(movingAtom.target);
                                movingAtom.nAtom.userData.isMoving = false;
                                animationState.movingNAtoms.splice(i, 1);
                                
                                // 移除路径
                                scene.remove(movingAtom.path);
                                
                                // 更新畸变效果
                                updateDistortion();
                            } else {
                                // 更新N原子位置
                                const from = movingAtom.nAtom.userData.originalPosition;
                                const to = movingAtom.target;
                                const t = movingAtom.progress;
                                
                                // 线性插值
                                const position = from.clone().lerp(to, t);
                                movingAtom.nAtom.position.copy(position);
                                
                                // 更新畸变效果
                                updateDistortion();
                            }
                        }
                        
                        // 随机选择一个N原子尝试跳跃
                        if (Math.random() < getNAtomJumpProbability() && animationState.movingNAtoms.length < 2) {
                            const availableNAtoms = nAtoms.filter(nAtom => !nAtom.userData.isMoving);
                            if (availableNAtoms.length > 0) {
                                const randomIndex = Math.floor(Math.random() * availableNAtoms.length);
                                const nAtom = availableNAtoms[randomIndex];
                                const neighbors = findNeighborOctahedrals(nAtom.position);
                                
                                if (neighbors.length > 0) {
                                    const targetIndex = Math.floor(Math.random() * neighbors.length);
                                    const target = neighbors[targetIndex].position;
                                    
                                    nAtom.userData.isMoving = true;
                                    nAtom.userData.originalPosition = nAtom.position.clone();
                                    
                                    // 创建路径
                                    const path = createJumpPath(nAtom.position, target);
                                    scene.add(path);
                                    
                                    animationState.movingNAtoms.push({
                                        nAtom: nAtom,
                                        target: target,
                                        progress: 0,
                                        path: path
                                    });
                                }
                            }
                        }
                    } else {
                        // 如果八面体间隙或N原子被隐藏，停止所有N原子的运动
                        for (let i = animationState.movingNAtoms.length - 1; i >= 0; i--) {
                            const movingAtom = animationState.movingNAtoms[i];
                            scene.remove(movingAtom.path);
                            movingAtom.nAtom.position.copy(movingAtom.nAtom.userData.originalPosition);
                            movingAtom.nAtom.userData.isMoving = false;
                        }
                        animationState.movingNAtoms = [];
                    }
                }
            }
            
            // 更新可见性
            updateVisibility();
            
            // 更新状态显示
            document.getElementById('current-mode').textContent = getModeName(animationState.mode);
            document.getElementById('current-temp').textContent = animationState.temperature;
            document.getElementById('current-state').textContent = animationState.isPlaying ? '运行中' : '暂停';
            
            renderer.render(scene, camera);
        }

        // 获取模式名称
        function getModeName(mode) {
            switch(mode) {
                case 'vacancy': return '空位扩散';
                case 'interstitial': return '间隙扩散';
                case 'combined': return '综合模式';
                default: return '未知';
            }
        }

        // 更新温度显示
        function updateTemperatureDisplay() {
            const temperatureElement = document.getElementById('temperature');
            temperatureElement.textContent = `温度: ${animationState.temperature} K`;
            
            // 根据温度改变颜色
            if (animationState.temperature < 300) {
                temperatureElement.style.background = '#3498db'; // 蓝色 - 低温
            } else if (animationState.temperature < 500) {
                temperatureElement.style.background = '#e67e22'; // 橙色 - 中温
            } else {
                temperatureElement.style.background = '#e74c3c'; // 红色 - 高温
            }
        }

        // 设置扩散模式
        function setMode(mode) {
            animationState.mode = mode;
            
            // 更新按钮状态
            document.getElementById('vacancy-mode').classList.remove('active');
            document.getElementById('interstitial-mode').classList.remove('active');
            document.getElementById('combined-mode').classList.remove('active');
            document.getElementById(mode + '-mode').classList.add('active');
            
            // 更新可见性
            updateVisibility();
            
            // 重置动画状态
            if (animationState.jumpPath) {
                scene.remove(animationState.jumpPath);
                animationState.jumpPath = null;
            }
            animationState.jumpingAtom = null;
            animationState.jumpProgress = 0;
            
            // 重置C原子移动状态
            animationState.movingCAtoms.forEach(movingAtom => {
                scene.remove(movingAtom.path);
                movingAtom.cAtom.position.copy(movingAtom.cAtom.userData.originalPosition);
                movingAtom.cAtom.userData.isMoving = false;
            });
            animationState.movingCAtoms = [];
            
            // 重置N原子移动状态
            animationState.movingNAtoms.forEach(movingAtom => {
                scene.remove(movingAtom.path);
                movingAtom.nAtom.position.copy(movingAtom.nAtom.userData.originalPosition);
                movingAtom.nAtom.userData.isMoving = false;
            });
            animationState.movingNAtoms = [];
            
            // 更新畸变效果
            updateDistortion();
        }

        // 切换UI显示状态
        function toggleUI() {
            animationState.uiVisible = !animationState.uiVisible;
            const uiElements = [
                document.getElementById('info'),
                document.getElementById('mode-panel'),
                document.getElementById('status'),
                document.querySelector('h1')
            ];
            
            uiElements.forEach(element => {
                if (element) {
                    element.classList.toggle('hidden', !animationState.uiVisible);
                }
            });
            
            document.getElementById('toggle-ui').textContent = 
                animationState.uiVisible ? '隐藏说明' : '显示说明';
        }

        // 控制按钮事件
        document.getElementById('playPause').addEventListener('click', function() {
            animationState.isPlaying = !animationState.isPlaying;
            this.textContent = animationState.isPlaying ? '暂停' : '继续';
        });

        document.getElementById('reset').addEventListener('click', function() {
            // 重置所有原子到原始位置
            for (const atom of atoms) {
                atom.position.copy(atom.userData.originalPosition);
                atom.userData.isVacancy = false;
                atom.userData.displaced = false;
            }
            
            // 重置空位
            animationState.currentVacancy.position.copy(initialVacancyPos);
            
            // 标记中心原子为空位
            const centerAtom = findAtomAtPosition(initialVacancyPos);
            if (centerAtom) {
                centerAtom.userData.isVacancy = true;
            }
            
            // 清除跳跃状态
            if (animationState.jumpPath) {
                scene.remove(animationState.jumpPath);
                animationState.jumpPath = null;
            }
            animationState.jumpingAtom = null;
            animationState.jumpProgress = 0;
            animationState.neighbors = findNeighborAtoms(initialVacancyPos);
            
            // 重置C原子位置
            for (const cAtom of cAtoms) {
                cAtom.position.copy(cAtom.userData.originalPosition);
                cAtom.userData.isMoving = false;
            }
            
            // 重置N原子位置
            for (const nAtom of nAtoms) {
                nAtom.position.copy(nAtom.userData.originalPosition);
                nAtom.userData.isMoving = false;
            }
            
            // 清除C原子移动状态
            for (const movingAtom of animationState.movingCAtoms) {
                scene.remove(movingAtom.path);
            }
            animationState.movingCAtoms = [];
            
            // 清除N原子移动状态
            for (const movingAtom of animationState.movingNAtoms) {
                scene.remove(movingAtom.path);
            }
            animationState.movingNAtoms = [];
            
            // 重置温度
            animationState.temperature = 300;
            updateTemperatureDisplay();
            
            // 更新畸变效果
            updateDistortion();
            
            // 重置相机位置
            camera.position.set(8, 8, 8);
            camera.lookAt(0, 0, 0);
            controls.reset();
        });

        document.getElementById('cool').addEventListener('click', function() {
            animationState.temperature = Math.max(100, animationState.temperature - 50);
            updateTemperatureDisplay();
        });

        document.getElementById('heat').addEventListener('click', function() {
            animationState.temperature = Math.min(800, animationState.temperature + 50);
            updateTemperatureDisplay();
        });

        // 模式选择按钮事件
        document.getElementById('vacancy-mode').addEventListener('click', function() {
            setMode('vacancy');
        });

        document.getElementById('interstitial-mode').addEventListener('click', function() {
            setMode('interstitial');
        });

        document.getElementById('combined-mode').addEventListener('click', function() {
            setMode('combined');
        });

        // 原子类型切换按钮事件
        document.getElementById('toggle-atoms').addEventListener('click', function() {
            animationState.showAtoms = !animationState.showAtoms;
            updateVisibility();
        });

        document.getElementById('toggle-vacancies').addEventListener('click', function() {
            animationState.showVacancies = !animationState.showVacancies;
            updateVisibility();
            updateDistortion(); // 更新畸变效果
        });

        document.getElementById('toggle-paths').addEventListener('click', function() {
            animationState.showPaths = !animationState.showPaths;
            updateVisibility();
        });

        document.getElementById('toggle-tetrahedral').addEventListener('click', function() {
            animationState.showTetrahedral = !animationState.showTetrahedral;
            updateVisibility();
        });

        document.getElementById('toggle-octahedral').addEventListener('click', function() {
            animationState.showOctahedral = !animationState.showOctahedral;
            updateVisibility();
        });

        document.getElementById('toggle-c-atoms').addEventListener('click', function() {
            animationState.showCAtoms = !animationState.showCAtoms;
            updateVisibility();
            updateDistortion(); // 更新畸变效果
        });

        document.getElementById('toggle-n-atoms').addEventListener('click', function() {
            animationState.showNAtoms = !animationState.showNAtoms;
            updateVisibility();
            updateDistortion(); // 更新畸变效果
        });

        document.getElementById('toggle-distortion').addEventListener('click', function() {
            animationState.showDistortion = !animationState.showDistortion;
            updateDistortion();
            updateVisibility();
        });

        // 扩散控制按钮事件
        document.getElementById('toggle-c-diffusion').addEventListener('click', function() {
            animationState.enableCDiffusion = !animationState.enableCDiffusion;
            updateVisibility();
        });

        document.getElementById('toggle-n-diffusion').addEventListener('click', function() {
            animationState.enableNDiffusion = !animationState.enableNDiffusion;
            updateVisibility();
        });

        // UI切换按钮事件
        document.getElementById('toggle-ui').addEventListener('click', toggleUI);

        // 窗口大小调整
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 初始化温度显示
        updateTemperatureDisplay();

        // 初始化可见性
        updateVisibility();

        // 初始化畸变效果
        updateDistortion();

        // 开始动画
        animate();
    </script>
</body>
</html>